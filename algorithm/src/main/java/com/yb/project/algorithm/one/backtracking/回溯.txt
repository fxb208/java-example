回溯算法是对树形或者图形结构执行一次深度优先遍历，实际上类似枚举的搜索尝试过程，在遍历的过程中寻找问题的解。
深度优先遍历有个特点：当发现已不满足求解条件时，就返回，尝试别的路径。此时对象类型变量就需要重置成为和之前一样，称为「状态重置」。
许多复杂的，规模较大的问题都可以使用回溯法，有「通用解题方法」的美称。
实际上，回溯算法就是暴力搜索算法，它是早期的人工智能里使用的算法，借助计算机强大的计算能力帮助我们找到问题的解。


回溯算法的本质是暴力穷举,即使用递归控制for循环嵌套的数量,本身不是一个高效的算法。
尽管可以使用剪枝来提高效率,但是还是改不了穷举的本质


记忆化回溯

回溯三部曲
1,递归函数的返回值以及参数
	List<List<Integer>> res=new ArrayList<List<Integer>>();
    List<Integer> path=new ArrayList<Integer>();
    int idx

2,回溯函数终止条件
	到达所谓的叶子节点
	
3,单层搜索的过程
	处理节点
	递归调用
	回溯，撤销本次处理的结果
	
基本范式
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}


回溯算法
组合
分割
排列
子集

不能有重复集的排序