1,Redis数据类型与结构，平时用哪些
 https://www.cnblogs.com/cnki/p/10505471.html
5种数据类型 string/set/list/zset/hash
string key-value缓存
hash 分布式session/购物车等
zset可以做排行榜 
配网移动 区局，施工单位进度排行榜可以考虑一下
list 消息队列系统/取前n条记录/
配网移动 施工数量时间轴可以考虑这个
set 

这一些列的博文介绍redis的很多方面
https://www.cnblogs.com/ysocean/p/9102811.html

2, 缓存穿透，缓存击穿，缓存雪崩区别及解决方案
https://blog.csdn.net/kongtiao5/article/details/82771694

a,缓存穿透：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为 -1 的数据或id为特别大不存在的数据
这时的用户很可能是攻击者，攻击会导致数据库压力过大。
解决方案：
接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，
缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
布隆过滤器

b,缓存击穿：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），
这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
解决方案：
1)热点数据不过期
2)互斥锁

c,缓存雪崩：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。
和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
解决方案：
1)缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2)如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3)设置热点数据永远不过期。

3,常用数据结构的时间复杂度和空间复杂度
https://www.jianshu.com/p/f31744e423eb
https://www.jianshu.com/p/f4cca5ce055a
a,比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。
 再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。
 比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 

b,再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。
二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 

c,O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 

d,O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 
哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）

4,Redis为什么这么快
a,redis是基于内存的，内存的读写速度非常快
b,采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，
不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
c,redis使用多路复用技术，可以处理并发的连接
https://www.jianshu.com/p/b08c1f3bb256

同时也可以回答，为什么redis是单线程的
Redis不涉及I/O操作，因此设计为单线程是效率最高的
https://my.oschina.net/hanchao/blog/3057400




