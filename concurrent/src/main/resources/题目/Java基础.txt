1，java反射机制
JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制

2，反射机制的作用
	（1）在运行时判断任意一个对象所属的类型。
	（2）在运行时构造任意一个类的对象。
	（3）在运行时判断任意一个类所具有的成员变量和方法。
	（4）在运行时调用任意一个对象的方法，甚至可以调用private方法。

3，反射机制会不会有性能问题
性能的开销主要在两方面：
	1)产生了Dynamic Resolve
无论是通过字符串获取Class、Method还是Field，都需要JVM的动态链接机制动态的进行解析和匹配，势必造成性能开销。 
	2)安全性验证
每一次的反射调用都会造成Java安全机制进行额外的安全性验证，造成性能开销。
	3)影响运行时优化
反射代码使得许多JVM的运行时优化无法进行。
处理方法
	1)使用Cache
针对上述原因1: 对通过反射调用获得的Class、Method、Field实例进行缓存，避免多次Dynamic Resolve。
	2)使用MethodHandle类
针对上述原因2：Java 7开始提供了java.lang.invoke.MethodHandle类，MethodHandle类的安全性验证在获取实例时进行而不是每次调用时都要进行验证，减小开销。
	3)使用Runtime创建的类
该方法最为强大，可以针对上述原因1、2、3进行全面优化。具体做法为：
在编译时设计好一个接口，由该接口封装所有的反射调用。
在运行时动态生成一个类实现该接口，该动态生成的类一旦完成define就和普通类没有区别，不需要后续的Dynamic Resolve，没有额外的安全性验证，也不会影响JVM的运行时优化。
该方法不能覆盖反射API的所有Use case，例如某个反射调用需要修改某实例的private字段，是无法动态生成一个合法的类这样去做的。


4，getDeclaredMethod：获取当前类的所有声明的方法，包括public、protected和private修饰的方法。
需要注意的是，这些方法一定是在当前类中声明的，从父类中继承的不算，实现接口的方法由于有声明所以包括在内。
getMethod：获取当前类和父类的所有public的方法。
这里的父类，指的是继承层次中的所有父类。
比如说，A继承B，B继承C，那么B和C都属于A的父类。

5,动态链接(解析阶段)
Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。
这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。
另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html
6,类加载过程
加载，验证，准备，解析，初始化
在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，
这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。
另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，
通常在一个阶段执行的过程中调用或激活另一个阶段

这里简要说明下 Java 中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对 Java 来说，绑定分为静态绑定和动态绑定：
静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 Java，简单的可以理解为程序编译期的绑定。
Java 当中的方法只有 final，static，private 和构造方法是前期绑定的。
动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。
在 Java 中，几乎所有的方法都是后期绑定的。

https://blog.csdn.net/lxlmycsdnfree/article/details/71404121
7 JDK动态代理，代理对象生成步骤
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
1)ProxyGenerator.generateProxyClass方法负责生成代理类的字节码，生成逻辑比较复杂，了解原理继续分析源码 sun.misc.ProxyGenerator
	byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                    proxyName, interfaces);
2)native方法Proxy.defineClass0负责字节码加载的实现，并返回对应的Class对象
	proxyClass = defineClass0(loader, proxyName,
                        proxyClassFile, 0, proxyClassFile.length);
3)利用clazz.newInstance反射机制生成代理类的对象

8 JIT 编译
java 程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，
这种方式的执行效率就显得很低。于是后来在虚拟机中引入了 JIT 编译器（即时编译器），
当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），
为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是 JIT 编译器。
1)默认（java -version混合模式）
2)解释模式（java -Xint -version）仅使用解释器方式执行
3)编译模式（java -Xcomp -version）优先采用编译方式执行程序，但解释器要在编译无法进行的情况下介入执行过程 

Interpreter 解释
Complier 编译

Java编译器：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），
这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。

Java解释器：是JVM的一部分。Java解释器用来解释执行Java编译器编译后的程序。java.exe可以简单看成是Java解释器。

作者：一个会写诗的程序员
链接：https://www.jianshu.com/p/2698d5a2603c
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。
字节码：字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。
Java字节码：是Java虚拟机执行的一种指令格式。

解释器：是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。
解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。
它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。
它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快。

即时编译(Just-in-time compilation: JIT)：又叫实时编译、及时编译。
是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。
这项技术是被用来改善虚拟机的性能的。JIT编译器是JRE的一部分。
原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。
为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。
而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。
它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。

二进制文件：广义的二进制文件即为文件，由文件在外部存储设备的存放方式为二进制而得名。
狭义的二进制文件即指除文本文件以外的文件。文本文件的格式包括：ASCII、MIME、txt

9,
